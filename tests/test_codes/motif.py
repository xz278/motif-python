"""
    Module for genearte analyze notifs
"""

from copy import deepcopy
from collections import Counter
from scipy.spatial.distance import pdist
from geopy.distance import vincenty
import numpy as np
import pandas as pd
import geohash
import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import folium 
import math
from copy import deepcopy

def approx_home_location(df, stay_region_col='stay_region'):
    """
    Calculate the home location based on the assumption that the most frequently visited location
    during 24:00 to 6:00 is the home location.


    Parameters:
    -----------
    df: Dataframe
        User location data


    Returns:
    --------
    home: String
        Home location in geohash value
    """

    df2 = df.copy()
    df2['hour'] = [x.hour for x in df2.index]
    df2 = df2.loc[df2['hour'].isin([0, 1, 2, 3, 4, 5])]
    home = Counter(df2[stay_region_col].dropna()).most_common()[0][0]

    return home


def generate_motifs(df, nodes, round_trip=True, insert_home=True,
                   dayofweek=[0, 1, 2, 3, 4], trav_dist_th=50000, valid_timeslot_th=8):
    """
    Generate moitfs for given data.

    Parameters:
    -----------
    df: DataFrame
        Location data.
    nodes: tuple
        Nodes generated by generate_daily_nodes().
    round_trip: bool
        Whether to consider only days that start and end at the same date.
        Default is True.
    insert_home: bool
        Whether to insert home location if the first timeslot of daily data is missing.
        Default is True.
    dayofweek: list of integers
        Which days in a week to consider, [0,1,2,3,4,5,6] for Mon, Tue, Thurs, Wed, Fri, Sat, and Sun.
        Defualt is weekdays.
    trav_dist_th: int
        Travel distance threshold used to filter out days on which the user travels to other cities.
        Default is 50000 meters (about 31 miles).
    valid_timeslot_th: int
        Valid time slot thresold required to compute daily motifs.
        Defualt is 8 intervals.

    Returns:
    --------
    motifs: list of dictionary
        List of motifs, key is a graph object, value is the list of timestamp for days having the same motif
    """

    df2 = df.copy()

    # compute home location if need to insert home location
    if insert_home:
        home = approx_home_location(df2)

    # generate motifs
    motifs = []

    for n in nodes:
        tsp = n[0]  # timestamp for current daily nodes
        list_nodes = n[1].node.dropna().tolist()

        # check day of week
        if n[0].dayofweek not in dayofweek:
            continue

        # check number of valid time slots
        if len(list_nodes) <= valid_timeslot_th:
            continue

        # fiter out days with abnormal travel distance
        # skip current daily nodes if the maximum of pair distances among daily
        # nodes exceed the threshold
        un = np.unique(list_nodes)
        un = [geohash.decode(x) for x in un]
        d = pdist(un, lambda x, y: vincenty(x, y).meters)
        if len(d) > 0 and (max(d) > trav_dist_th):
            continue

        # insert home location is necessary
        if insert_home and (type(n[1].ix[0, 'node']) is not str):
            list_nodes.insert(0, home)

        # check whether the day is a round trip if specified
        if round_trip and (list_nodes[0] != list_nodes[-1]):
            continue

        # generate graph
        g = nx.DiGraph()
        # add nodes/daily visited locations
        g.add_nodes_from(list_nodes)
        # add edges
        for i in range(1, len(list_nodes)):
            if list_nodes[i] != list_nodes[i - 1]:
                g.add_edge(list_nodes[i - 1], list_nodes[i])
        g = nx.freeze(g)

        # check graph equality
        found = False
        for item in motifs:
            if nx.is_isomorphic(item['graph'], g):
                item['data'].append(tsp)
                found = True
                break
        if not found:
            motifs.append({'graph': g, 'data': [tsp]})

    return motifs


def add_motifs(motifs, new_motifs):
    """
    Check equality of motifs returned by generate_motifs().
    Add newly generated motifs to moitfs overall motifs.
    This method is used to store motifs for multiple users.

    Parameters:
    -----------
    motifs: list of dictionaries
        Overall motifs.
    new_motifs: list of dictionaries
        Motifs that are to be added to overall motifs.

    Returns:
    motifs: list of dictionaries
        Overall motifs.
    """
    for nm in new_motifs:
        found = False
        for m in motifs:
            if nx.is_isomorphic(m['graph'], nm['graph']):
                m['data'].extend(nm['data'])
                found = True
                break
        if not found:
            motifs.append(nm)
    return motifs


def plot_motifs(motifs, ax=None):
    """
    Plot 20 most frequent motifs and correspoding frequency in ascending order of number of nodes.

    Parameters:
    -----------
    motifs: list of dictionaries
        Motifs to plot.
    ax: matplotlib.axes._subplots.AxesSubplot instance
        Axes on which to plot the motifs.
        Default is None.

    Returns:
    fig: matplotlib.figure.Figure instance
        if ax is None, create a new figure to plot the motifs and return the motif,
        otherwise return None.
    ax: matplotlib.axes._subplots.AxesSubplot instance
        Axes on which the motifs are plot.
    """
    num_motif = len(motifs)

    # return None, None if no motifs
    if num_motif == 0:
        return None, None

    # sort motifs by frequency
    motifs = sort_motif_by_freq(motifs)

    # plot motifs
    # if ax is None, create a new figure and axes
    if ax is None:
        fig = plt.figure(figsize=(20, 5))
        ax = fig.add_subplot(1, 1, 1)
        ax = _plot_motifs(ax, motifs)
    else:  # else return None for figure, and return the axes
        ax = _plot_motifs(ax, motifs)
        fig = None

    return(fig, ax)


def _plot_motifs(ax, motifs):
    """
    Plot the first 20 motifs and frequency.

    Parameters:
    -----------
    ax: matplotlib.axes._subplots.AxesSubplot instance
        Axes on which to plot the motifs.
    motifs: list of dictionaries

    Returns:
    --------
    ax: matplotlib.axes._subplots.AxesSubplot instance
        Axes on which the motifs are plotted.
    """

    # w = 1 / len(motifs)

    # plot motif
    w = 1/20
    b_w = w * 0.4
    bar_pos_diff = (w - b_w) / 2

    # total number of motifs
    sum_i = 0
    for m in motifs:
        sum_i += len(m['data'])

    # select the first 20 motifs and sort by number of nodes in ascending order
    motifs = motifs[:20]
    motifs = sort_motif_by_nodes(motifs)
    
    index = 0
    # plot motifs
    for m in motifs:
        subpos = [w*(index),0.8,w,0.2]
        subax = add_subplot_axes(ax,subpos)
        nx.draw_spectral(m['graph'], ax=subax, node_size=20)
        p = patches.Rectangle((w*(index) + bar_pos_diff,0),b_w,len(m['data'])/sum_i)
        ax.add_patch(p)
        index += 1
    num_motifs = len(motifs)
    ticks = range(num_motifs)
    ticks = [w/2 + t*w for t in ticks]
    ax.set_xticks(ticks)
    ax.set_xticklabels(range(1,num_motifs+1))
    ax.set_yticks(np.linspace(0,1,11))
    return ax


def sort_motif_by_freq(motifs):
    """
    Sort motifs by frequency.
    """
    m = deepcopy(motifs)
    m.sort(key=lambda x:len(x['data']), reverse=True)
    return m

def sort_motif_by_nodes(motifs):
    """
    Sort motifs by number of nodes.
    """
    m = deepcopy(motifs)
    m.sort(key=lambda x:len(x['graph'].nodes()))
    return m

def compute_regularity(df):
    """
    Calculate mobility regularity R(t), which is defined as the probability of 
    finding the user in her/his most visited location at hourly interval in a
    week (Jiang S et al, 2010)
    [http://humnetlab.mit.edu/wordpress/wp-content/uploads/2010/10/ACM13_ShanJiangII.pdf]
    
    Parameters:
    -----------
    df: DataFrame
        location data    
    
    Returns:
    --------
    reg: list of floats
        mobility regularity in hourly interval in a week
    """
    
    D = {}        # a dictionary stores location visited for intervals, there are 7x4 hourly intervals, 
                # each key is a tuple of dayofweek and hour. (dayofweek, hour)
                # where dayofweek is in [0..6] standing for [Monday,..,Sunday], hour is in [0..23],
                # each value is a list of visted location during that interval.
                # eg. {(5,13):[a,b,c,a]} means during 13:00 - 14:00 on Fridays the participant
                # visited location [a,b,c,a]
    
    R = {}        # a dictionary storing mobility regularity for each interval
                # each key is a tuple of dayofweek and hour. (dayofweek, hour)
                # where dayofweek is in [0..6] standing for [Monday,..,Sunday], hour is in [0..23],
                # each value is float, the regularity value for that interval.
                # eg. {(5,13):0.6} means during 13:00 - 14:00 on Fridays the regularity is 0.6

    # initialize D and R
    for day in range(7):        # for each day of week
        for hour in range(24):    # for each hour of the day
            D[(day,hour)] = []
            R[(day,hour)] = 0
            
    # group locatino data based on hour and dayofweek
    df2 = df.copy()
    df2['hour'] = [x.hour for x in df2.index]
    df2['dayofweek'] = [x.dayofweek for x in df2.index]
    grouped = df2.groupby(['dayofweek', 'hour'])
    
    # compute visited locations for each interval
    for index, group in grouped:

        # get day of week and 
        dayofweek = index[0]
        hour = index[1]

        # add visited locations to corresponding interval
        visited_locations = group.stay_region.dropna()
        D[(dayofweek, hour)].extend(visited_locations)
        
    # compute regularity
    for key, value in D.items():

        # total number of visited locations with duplicates
        num_locations = len(value)

        # get most frequent visited location and calculate its frequency
        c = Counter(value)
        if len(c) > 0:
            num_most_common_location = c.most_common()[0][1] 
            R[(key[0],key[1])] = num_most_common_location / num_locations 
    
    # convert regulariy infomation in R to a list in time order from 0:00 Monday to 23:00 Sunday
    reg = []
    for day in range(7):
        for hour in range(24):
            reg.append(R[day,hour])

    return reg

def plot_regularity(reg, ax=None):
    """
    Plot regularity.

    Parameters:
    -----------
    reg: list of float
        Regularity values from 0:00 on Monday to 23:00 on Sunday
    ax: matplotlib.axes._subplots.AxesSubplot instance
        Axes on which to plot regularity.

    Returns:
    --------    
    fig: matplotlib.figure.Figure instance
        if ax is None, create a new figure to plot regularity,
        otherwise return None.
    ax: matplotlib.axes._subplots.AxesSubplot instance
        Axes on which regularity is plotted.
    """

    # create a new figure and subaxes if as is None
    if ax is None:
        fig, ax = plt.subplots(1,1)
    else:
        fig = None
    # plot lines to seperate each day
    ax.plot(list(range(24*7)), reg)

    # plot regularity 
    for i in range(1, 7):
        ax.plot([i*24,i*24], [0, 1], color='0.4', linewidth=0.2, linestyle='--')

    # set plot configurations
    ax.set_xticks([11+x*24 for x in range(7)])
    ax.set_xticklabels(['Mon', 'Tue', 'Wed', 'Thur', 'Fri', 'Sat', 'Sun'])
    ax.set_ylabel('R(t)')
    ax.set_xlabel('Time(t)')
    ax.grid('off')
    ax.spines['top'].set_color('b')
    ax.spines['right'].set_visible(True)
    ax.spines['top'].set_visible(True)

    return fig, ax



def compute_gyration_radius(df, sr_c='stay_region', long_trip_th=50000, home=None):
    """
    This function computes the total radius of gyration and k-radius gyration for an individual
    based on visitied locations.
    
    The total radius of gyration is used to characterize the typical distance travelled by an individual.
    The k-radius of gyration is the radius of gyration computed over the k-th most frequent locations.
    
    [Gonzalez M. C., Hidalgo C. A. & Barabasi A. L. Understanding individual human mobility patterns. Nature 453, 779–782 (2008).]
    

    Parameters:
    -----------    
    df: DataFrame
        Location data including column 'stay_region'
    sr_c: str
        Stay region column name.
        Default is 'stay_region'
    long_trip_th: float
        Threshold to filter out locations that are presumedly not at the same city as home location.
        Default is 50000 meters, about 31 miles. 
    home: str
        Home location.
        Default is None, and it is then approximated based on the participant location data history.

    Returns:
    --------
    total_rg: float
        total radius of gyration
        
    k_th_rg: DataFrame
        k-th radius of gyration in descending order of frequented locations
        
    detail_info: Dataframe
        detail information for significant locations including 
        geohash values, gps coordinates, count, k-th radius of gyration
    """
    
    df2 = df.copy()
    visited_locations = df2[sr_c].dropna()
    unique_visited_locations = np.unique(visited_locations).tolist()

    # remove locations that are faraway from home location
    if home is None:
        home = geohash.decode(approx_home_location(df))
    c = Counter(visited_locations)
    for k in c.keys():
        if (vincenty(home, geohash.decode(k)).meters > long_trip_th):
            if k in unique_visited_locations:
                unique_visited_locations.remove(k)
    
    # assign gps coordinate to each stay_region
    df2 = df2.loc[df['stay_region'].isin(unique_visited_locations), :]
    geohash_to_gps = {}
    for g in unique_visited_locations:
        geohash_to_gps[g] = geohash.decode(g)
    df2['lat2'] = [geohash_to_gps[x][0] for x in df2.stay_region]
    df2['lon2'] = [geohash_to_gps[x][1] for x in df2.stay_region]
        
    visited_locations = df2.stay_region
    unique_visited_locations_gps = [geohash.decode(x) for x in unique_visited_locations]
    num_places = len(unique_visited_locations)
    num_points = len(visited_locations)
    
    # construct a DataFrame to store significant places' info
    significant_places = pd.DataFrame(columns =['geo_hash','lat','lon','count','pct','gyration_radius','k'])
    significant_places['geo_hash'] = unique_visited_locations
    significant_places.lat = [x[0] for x in unique_visited_locations_gps]
    significant_places.lon = [x[1] for x in unique_visited_locations_gps]
    significant_places.ix[:,'count'] = 0
    significant_places.ix[:,'gyration_radius'] = 0
    significant_places = significant_places.set_index('geo_hash')
    
    # calculate frequency of each visited location
    c = Counter(visited_locations)
    for v in c:
        if v in significant_places.index:
            significant_places.ix[v,'count'] = c[v]

    # calculate percentage of each location
    for n in range(num_places):
        significant_places.ix[n,'pct'] = significant_places.ix[n,'count'] / num_points
            
    significant_places = significant_places.sort_values(by='count', ascending=False)
    significant_places.ix[:,'k'] = [ x+1 for x in range(num_places)]
    
    # compute tatol radius of gyration
    
    # total number of visits
    N = num_points
    
    # r_cm is the center of mass of individual
    locations_included = significant_places.index
    r_cm = get_geo_center(df2.loc[df2['stay_region'].isin(locations_included)], 
                          lat_c='lat2', lon_c='lon2')
    r_cm = (r_cm['latitude'],r_cm['longitude'])        # center of mass of the individual

    temp_sum = 0
    for i in range(num_places):

        # current location coordinates
        r = (significant_places.ix[i,'lat'], significant_places.ix[i,'lon'])
        
        temp_sum += significant_places.ix[i,'count'] * vincenty(r,r_cm).km**2
    total_rg = math.sqrt(1/N * temp_sum)
    
    # compute k-radius of gyration
    for i in range(num_places):
        N = significant_places.ix[:i+1,'count'].sum()
        locations_included = significant_places.index[:i+1]
        r_cm = get_geo_center(df2.loc[df2['stay_region'].isin(locations_included)], 
                              lat_c='lat2', lon_c='lon2')
        r_cm = (r_cm['latitude'],r_cm['longitude'])
        temp_sum = 0
        for j in range(i+1):
            r = (significant_places.ix[j,'lat'], significant_places.ix[j,'lon'])
            temp_sum += significant_places.ix[j,'count'] * vincenty(r,r_cm).km**2
        if temp_sum > 0:
            significant_places.ix[i,'gyration_radius'] = math.sqrt(1/N * temp_sum)

    
    if num_places==1:
        significant_places['ratio_k'] = 1
    else:
        significant_places['ratio_k'] = [x/total_rg for x in significant_places.gyration_radius]
    
    k_th_rg = significant_places.ix[:,['gyration_radius','k','ratio_k']].set_index('k')
    
    detail_info = significant_places
    
    return(total_rg,k_th_rg,detail_info)


def plot_daily_visited_locations(motifs, ax=None):
    """
    Plot daily visited locations in ascending order of number of daily nodes.
    
    Parameters:
    -----------
    motifs: list
        list of motifs
    
    ax: matplotlib.axes._subplots.AxesSubplot
        axes on which to plot the stats
        
    Returns:
    --------
    ax: matplotlib.axes._subplots.AxesSubplot
        axes on which the stats are plotted
    """
    distr = {}      # daily visited nodes distribution
                    # key is number of daily visited nodes
                    # value is number of occurance
    for m in motifs:
        num_visited = len(m['graph'].nodes())
        c = len(m['data'])
        if num_visited in distr:
            distr[num_visited] += c
        else:
            distr[num_visited] = c
                
    if ax is None:
        fig = plt.figure(figsize=(5,3))
        ax = fig.add_subplot(1,1,1)
    else:
        fig = None

    nbarx = list(distr.keys())
    nbarx.sort()
    s = sum(distr.values())
    m = sum(distr.keys())
    nbary = [distr[x]/s for x in nbarx]
    ind = np.arange(len(nbarx))  # the x locations for the groups
    width = 0.2     # the width of the bars
    rects1 = ax.bar(ind, nbary, width, color='b')
    ax.set_xticks(ind+width/2)
    ax.set_xticklabels(nbarx)
    ax.set_yticks(np.linspace(0,1,11))

    return(fig, ax)


def add_subplot_axes(ax, rect, axisbg='w'):
    """
    from http://stackoverflow.com/questions/17458580/embedding-small-plots-inside-subplots-in-matplotlib
    example:
    
        fig = plt.figure(figsize=(10,10))
        axes = []
        subpos = [0.2,0.6,0.3,0.3]
        x = np.linspace(-np.pi,np.pi)
        for i in range(4):
            axes.append(fig.add_subplot(2,2,i))
        for axis in axes:
            axis.set_xlim(-np.pi,np.pi)
            axis.set_ylim(-1,3)
            axis.plot(x,np.sin(x))
            subax1 = add_subplot_axes(axis,subpos)
            subax2 = add_subplot_axes(subax1,subpos)
            subax1.plot(x,np.sin(x))
            subax2.plot(x,np.sin(x))
    
    """
    fig = plt.gcf()
    box = ax.get_position()
    width = box.width
    height = box.height
    inax_position  = ax.transAxes.transform(rect[0:2])
    transFigure = fig.transFigure.inverted()
    infig_position = transFigure.transform(inax_position)    
    x = infig_position[0]
    y = infig_position[1]
    width *= rect[2]
    height *= rect[3]  
    subax = fig.add_axes([x,y,width,height],axisbg=axisbg)

    return subax

def get_geo_center(df, lat_c='latitude', lon_c='longitude'):
    """
    Calculates center of given geo points.
    
    To avoid "wrap-around" issues (near international dateline),
    this method follows [1].
    
    Parameters
    ----------
    df: DataFrame
    
    lat_c: str
        Column name containing latitudes. Default is latitude.
    lon_c: str
        Column name containing longitudes. Default is longitude
        
    Returns
    -------
    d: dict
        Keys 'latitude' and 'longitude' indicate
        the coordinates of the center point.

    [1]: https://carto.com/blog/center-of-points/
    """
    
    lat = df[lat_c]
    lon = df[lon_c]
    
    angle = math.pi / 180
    
    center_lat = math.atan2(np.mean(np.sin(lat * angle)), 
                            np.mean(np.cos(lat * angle))) * 180 / math.pi
    
    center_lon = math.atan2(np.mean(np.sin(lon * angle)), 
                            np.mean(np.cos(lon * angle))) * 180 / math.pi
    
    return {'longitude': center_lon, 'latitude': center_lat}